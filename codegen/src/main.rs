// SPDX-License-Identifier: CC0-1.0

//! Code generation tool for Bitcoin Core JSON-RPC API types.
//!
//! This tool reads an OpenRPC specification (as generated by Bitcoin Core v30+) and generates
//! Rust type definitions that can be used with the `corepc-types` crate.
//!
//! # Usage
//!
//! ```bash
//! cargo run --bin corepc-codegen -- --input OpenRPC.json --output types/src/v30 --version v30
//! ```

mod generator;
mod modules;
mod schema;

use std::collections::BTreeMap;
use std::fs;
use std::path::PathBuf;

use anyhow::{Context, Result};
use clap::Parser;
use regex::Regex;

use crate::generator::GeneratorConfig;
use crate::modules::{generate_mod_rs, generate_modules};
use crate::schema::OpenRpcDocument;

/// Code generator for Bitcoin Core RPC types from OpenRPC specification.
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Path to the OpenRPC.json file.
    #[arg(short, long)]
    input: PathBuf,

    /// Output directory for generated files.
    #[arg(short, long)]
    output: PathBuf,

    /// Bitcoin Core version (e.g., "v30").
    #[arg(short = 'c', long = "core-version")]
    core_version: String,

    /// Only print what would be generated, don't write files.
    #[arg(long, default_value = "false")]
    dry_run: bool,

    /// Generate a single combined file instead of separate modules.
    #[arg(long, default_value = "false")]
    single_file: bool,

    /// Compare with existing types directory and output differences.
    #[arg(long)]
    compare: Option<PathBuf>,

    /// Patch existing types directory with generated optionality fixes.
    /// This will update struct field types in-place where optionality differs.
    #[arg(long)]
    patch: Option<PathBuf>,

    /// Append specific generated types to the existing module.
    /// Provide comma-separated struct names to append, e.g., "RestoreWallet,UnloadWallet"
    #[arg(long)]
    append_types: Option<String>,
}

fn main() -> Result<()> {
    let args = Args::parse();

    // Read and parse the OpenRPC document
    let content = fs::read_to_string(&args.input)
        .with_context(|| format!("Failed to read input file: {:?}", args.input))?;

    let doc: OpenRpcDocument = serde_json::from_str(&content)
        .with_context(|| "Failed to parse OpenRPC document")?;

    println!(
        "Parsed OpenRPC document: {} ({})",
        doc.info.title, doc.info.version
    );
    println!("Found {} methods", doc.methods.len());

    // Generate modules
    let config = GeneratorConfig::default();
    let modules = generate_modules(&doc.methods, config);

    println!("Generated {} modules:", modules.len());
    for module in &modules {
        println!(
            "  - {}: {} types from {} methods",
            module.name,
            module.exports.len(),
            module.methods.len()
        );
    }

    if args.dry_run {
        println!("\n[DRY RUN] Would generate the following files:");
        for module in &modules {
            if !module.exports.is_empty() {
                println!("  - {}/{}.rs", args.output.display(), module.name);
            }
        }
        println!("  - {}/mod.rs", args.output.display());
        return Ok(());
    }

    // Create output directory
    fs::create_dir_all(&args.output)
        .with_context(|| format!("Failed to create output directory: {:?}", args.output))?;

    if args.single_file {
        // Generate a single combined file
        let mut combined = String::new();
        combined.push_str(&generate_mod_rs(&modules, &args.core_version));
        combined.push_str("\n// ============ Generated Types ============\n\n");

        for module in &modules {
            if !module.exports.is_empty() {
                combined.push_str(&format!("\n// --- {} ---\n\n", module.name));
                combined.push_str(&module.code);
            }
        }

        let output_path = args.output.join("generated.rs");
        fs::write(&output_path, &combined)
            .with_context(|| format!("Failed to write: {:?}", output_path))?;
        println!("Wrote: {:?}", output_path);
    } else {
        // Generate separate module files
        for module in &modules {
            if !module.exports.is_empty() {
                let output_path = args.output.join(format!("{}.rs", module.name));
                fs::write(&output_path, &module.code)
                    .with_context(|| format!("Failed to write: {:?}", output_path))?;
                println!("Wrote: {:?}", output_path);
            }
        }

        // Generate mod.rs
        let mod_rs = generate_mod_rs(&modules, &args.core_version);
        let mod_path = args.output.join("mod.rs");
        fs::write(&mod_path, &mod_rs)
            .with_context(|| format!("Failed to write: {:?}", mod_path))?;
        println!("Wrote: {:?}", mod_path);
    }

    println!("\nCode generation complete!");

    // If compare directory is specified, compare generated types with existing
    if let Some(compare_dir) = &args.compare {
        compare_types(&args.output, compare_dir)?;
    }

    // If patch directory is specified, patch existing types with generated optionality
    if let Some(patch_dir) = &args.patch {
        patch_types(&args.output, patch_dir)?;
    }

    // If append_types is specified, append specific types to existing modules
    if let Some(type_list) = &args.append_types {
        let types_to_append: Vec<&str> = type_list.split(',').map(|s| s.trim()).collect();
        if let Some(patch_dir) = &args.patch {
            append_types_to_module(&args.output, patch_dir, &types_to_append)?;
        } else {
            println!("Warning: --append-types requires --patch to specify target directory");
        }
    }

    Ok(())
}

/// Extract struct definitions and their fields from Rust source code.
fn extract_struct_fields(code: &str) -> BTreeMap<String, BTreeMap<String, String>> {
    use std::collections::BTreeMap;
    
    let mut structs = BTreeMap::new();
    let struct_re = Regex::new(r"pub struct (\w+)\s*\{([^}]*)\}").unwrap();
    let field_re = Regex::new(r"pub\s+(\w+):\s*([^,\n]+)").unwrap();
    
    for cap in struct_re.captures_iter(code) {
        let struct_name = cap[1].to_string();
        let body = &cap[2];
        
        let mut fields = BTreeMap::new();
        for field_cap in field_re.captures_iter(body) {
            let field_name = field_cap[1].to_string();
            let field_type = field_cap[2].trim().trim_end_matches(',').to_string();
            fields.insert(field_name, field_type);
        }
        structs.insert(struct_name, fields);
    }
    structs
}

/// Compare generated types with existing types and report differences.
fn compare_types(generated_dir: &PathBuf, existing_dir: &PathBuf) -> Result<()> {
    use std::collections::BTreeMap;
    
    println!("\n=== Type Comparison Report ===\n");
    
    // Read all .rs files from both directories
    for entry in fs::read_dir(generated_dir)? {
        let entry = entry?;
        let path = entry.path();
        if path.extension().map_or(false, |e| e == "rs") {
            let file_name = path.file_name().unwrap().to_str().unwrap();
            if file_name == "mod.rs" {
                continue;
            }
            
            let gen_code = fs::read_to_string(&path)?;
            let gen_structs = extract_struct_fields(&gen_code);
            
            // Find corresponding file in existing directory
            let existing_path = existing_dir.join(file_name);
            let existing_structs = if existing_path.exists() {
                let existing_code = fs::read_to_string(&existing_path)?;
                extract_struct_fields(&existing_code)
            } else {
                // Try looking in subdirectory (e.g., wallet/mod.rs)
                let module_name = file_name.trim_end_matches(".rs");
                let subdir_path = existing_dir.join(module_name).join("mod.rs");
                if subdir_path.exists() {
                    let existing_code = fs::read_to_string(&subdir_path)?;
                    extract_struct_fields(&existing_code)
                } else {
                    println!("Module {} not found in existing types", module_name);
                    BTreeMap::new()
                }
            };
            
            // Compare struct by struct
            let module_name = file_name.trim_end_matches(".rs");
            let mut has_differences = false;
            
            for (struct_name, gen_fields) in &gen_structs {
                if let Some(existing_fields) = existing_structs.get(struct_name) {
                    // Compare fields
                    for (field_name, gen_type) in gen_fields {
                        if let Some(existing_type) = existing_fields.get(field_name) {
                            // Check if optionality differs
                            let gen_optional = gen_type.starts_with("Option<");
                            let existing_optional = existing_type.starts_with("Option<");
                            if gen_optional != existing_optional {
                                if !has_differences {
                                    println!("=== {} ===", module_name);
                                    has_differences = true;
                                }
                                println!(
                                    "  {}.{}: optionality mismatch",
                                    struct_name, field_name
                                );
                                println!("    OpenRPC: {}", gen_type);
                                println!("    Existing: {}", existing_type);
                            }
                        } else {
                            if !has_differences {
                                println!("=== {} ===", module_name);
                                has_differences = true;
                            }
                            println!(
                                "  {}.{}: MISSING in existing types",
                                struct_name, field_name
                            );
                            println!("    OpenRPC type: {}", gen_type);
                        }
                    }
                    
                    // Check for fields in existing but not in generated
                    for (field_name, existing_type) in existing_fields {
                        if !gen_fields.contains_key(field_name) {
                            if !has_differences {
                                println!("=== {} ===", module_name);
                                has_differences = true;
                            }
                            println!(
                                "  {}.{}: EXTRA in existing types (not in OpenRPC)",
                                struct_name, field_name
                            );
                            println!("    Existing type: {}", existing_type);
                        }
                    }
                }
            }
            
            if has_differences {
                println!();
            }
        }
    }
    
    Ok(())
}

/// Patch existing types with generated optionality fixes.
/// This updates struct field types in-place where optionality differs.
fn patch_types(generated_dir: &PathBuf, existing_dir: &PathBuf) -> Result<()> {
    println!("\n=== Patching Types ===\n");
    
    let mut total_patches = 0;
    let mut types_to_add: Vec<(String, String)> = Vec::new(); // (module_name, struct_code)
    
    // Read all .rs files from generated directory
    for entry in fs::read_dir(generated_dir)? {
        let entry = entry?;
        let path = entry.path();
        if path.extension().map_or(false, |e| e == "rs") {
            let file_name = path.file_name().unwrap().to_str().unwrap();
            if file_name == "mod.rs" {
                continue;
            }
            
            let gen_code = fs::read_to_string(&path)?;
            let gen_structs = extract_struct_fields(&gen_code);
            
            // Find corresponding file in existing directory
            let module_name = file_name.trim_end_matches(".rs");
            let existing_path = existing_dir.join(file_name);
            let target_path = if existing_path.exists() {
                existing_path
            } else {
                // Try looking in subdirectory (e.g., wallet/mod.rs)
                let subdir_path = existing_dir.join(module_name).join("mod.rs");
                if subdir_path.exists() {
                    subdir_path
                } else {
                    println!("Module {} not found in existing types, skipping", module_name);
                    continue;
                }
            };
            
            let mut existing_code = fs::read_to_string(&target_path)?;
            let existing_structs = extract_struct_fields(&existing_code);
            let mut file_patches = 0;
            
            // For each struct in generated code
            for (struct_name, gen_fields) in &gen_structs {
                if let Some(existing_fields) = existing_structs.get(struct_name) {
                    // For each field, check if optionality needs to change
                    for (field_name, gen_type) in gen_fields {
                        if let Some(existing_type) = existing_fields.get(field_name) {
                            let gen_optional = gen_type.starts_with("Option<");
                            let existing_optional = existing_type.starts_with("Option<");
                            
                            // Only patch if generated says Option and existing doesn't
                            // (making fields MORE optional, not less)
                            if gen_optional && !existing_optional {
                                // Build regex to find and replace the field type
                                let pattern = format!(
                                    r"(pub\s+{}\s*:\s*){}",
                                    regex::escape(field_name),
                                    regex::escape(existing_type)
                                );
                                let re = Regex::new(&pattern).unwrap();
                                
                                // Extract inner type and wrap in Option
                                let new_type = format!("Option<{}>", existing_type);
                                let replacement = format!("${{1}}{}", new_type);
                                
                                if re.is_match(&existing_code) {
                                    existing_code = re.replace(&existing_code, replacement.as_str()).to_string();
                                    println!(
                                        "  Patched {}.{}: {} -> {}",
                                        struct_name, field_name, existing_type, new_type
                                    );
                                    file_patches += 1;
                                }
                            }
                        }
                    }
                } else {
                    // Struct doesn't exist in this module - check if we should add it
                    // Extract the full struct definition from generated code
                    let struct_re = Regex::new(&format!(
                        r"(?s)(///[^\n]*\n)*#\[derive\([^\]]*\)\]\n(?:#\[[^\]]*\]\n)*pub struct {}\s*\{{[^}}]*\}}",
                        regex::escape(struct_name)
                    )).unwrap();
                    
                    if let Some(cap) = struct_re.captures(&gen_code) {
                        let struct_def = cap[0].to_string();
                        types_to_add.push((module_name.to_string(), struct_def));
                        println!("  Type {} needs to be added to {}", struct_name, module_name);
                    }
                }
            }
            
            if file_patches > 0 {
                fs::write(&target_path, &existing_code)?;
                println!("  Wrote {} patches to {:?}", file_patches, target_path);
                total_patches += file_patches;
            }
        }
    }
    
    if total_patches > 0 {
        println!("\nTotal patches applied: {}", total_patches);
    } else {
        println!("No patches needed.");
    }
    
    if !types_to_add.is_empty() {
        println!("\n=== Types to Add ===\n");
        println!("The following types from OpenRPC are not in the existing module files.");
        println!("They may be re-exported from earlier versions with different field optionality.");
        println!("To fix, add these type definitions to the appropriate v30 module:\n");
        
        for (module, struct_def) in &types_to_add {
            println!("// Add to types/src/v30/{}/mod.rs:", module);
            println!("{}\n", struct_def);
        }
    }
    
    Ok(())
}

/// Append specific types from generated code to the existing module files.
fn append_types_to_module(
    generated_dir: &PathBuf,
    existing_dir: &PathBuf,
    types_to_append: &[&str],
) -> Result<()> {
    println!("\n=== Appending Types ===\n");

    // Find which module each type belongs to
    for entry in fs::read_dir(generated_dir)? {
        let entry = entry?;
        let path = entry.path();
        if path.extension().map_or(false, |e| e == "rs") {
            let file_name = path.file_name().unwrap().to_str().unwrap();
            if file_name == "mod.rs" {
                continue;
            }

            let gen_code = fs::read_to_string(&path)?;
            let module_name = file_name.trim_end_matches(".rs");

            // Find target file
            let target_path = existing_dir.join(module_name).join("mod.rs");
            if !target_path.exists() {
                continue;
            }

            let mut appended = Vec::new();

            for type_name in types_to_append {
                // Extract the full struct definition from generated code
                let struct_re = Regex::new(&format!(
                    r"(?s)(///[^\n]*\n)*#\[derive\([^\]]*\)\]\n(?:#\[[^\]]*\]\n)*pub struct {}\s*\{{[^}}]*\}}",
                    regex::escape(type_name)
                ))
                .unwrap();

                if let Some(cap) = struct_re.captures(&gen_code) {
                    let struct_def = cap[0].to_string();
                    appended.push((type_name.to_string(), struct_def));
                }
            }

            if !appended.is_empty() {
                let mut existing_code = fs::read_to_string(&target_path)?;
                
                existing_code.push_str("\n// === Generated types for v30 ===\n\n");
                
                for (type_name, struct_def) in &appended {
                    existing_code.push_str(&format!("/// Generated from OpenRPC specification.\n"));
                    existing_code.push_str(struct_def);
                    existing_code.push_str("\n\n");
                    println!("  Appended {} to {:?}", type_name, target_path);
                }

                fs::write(&target_path, &existing_code)?;
            }
        }
    }

    Ok(())
}
